select  
  xnum, ynum, znum
  , sum(sumploverx) over (partition by ynum,znum order by xnum rows between current row and znum-1 following) as sumall
from (
  select * from (
    with gridinput as (select 7689 grid_sn, 300 gridsize from dual)
        ,rowgen as (select level num from dual connect by 1=1 and level <= 300)
        ,powerlevel as 
          (select x.num xnum, y.num ynum
             , mod(trunc(((x.num+10)*y.num+g.grid_sn)*(x.num+10)/100),10)-5 pl
           from rowgen x, rowgen y, gridinput g
          )
    select p.xnum, p.ynum, p.pl, z.num znum
      , sum(p.pl) over (partition by p.xnum,z.num order by p.ynum rows between current row and z.num-1 following) as sumploverx
    from powerlevel p, rowgen z
    )
  )
order by sumall desc fetch first 1 rows only
/
--90	169	15	103
/*
  square: (90,169)
  size: 15
  sum of powerlevel: 103
--about two minutes


-- "with" lets you define views, basically
-- view for parameters
with gridinput as (select 7689 grid_sn, 300 gridsize from dual)

-- view with row values 1 to 300; I should have used gridinput.gridsize but I didn't want to mess with it
rowgen as (select level num from dual connect by 1=1 and level <= 300)

-- view that generates (x,y,powerlevel); the pl term is just derived from the problem description
-- no where clause, Cartesian join baby! 
powerlevel as 
  (select x.num xnum, y.num ynum
    , mod(trunc(((x.num+10)*y.num+g.grid_sn)*(x.num+10)/100),10)-5 pl
   from rowgen x, rowgen y, gridinput g
  )

/*
I'm using view rowgen z to represent square sizes from 1 to 300
For each (x,y) and column size z, what is the sum of powerlevels?
  that is, sum( pl(x,y)+pl(x,y+1) ... pl(x, (y+(z-1)) )
  (z-1) because a window of size 1 is (x,y) to (x,y); even in sql you have the off-by-one problem

This is the magic, using the analytic version of sum().
Basically, an analytic function lets you create results for _this_ row by processing values from _other_ rows.
, sum(p.pl) over (partition by p.xnum,z.num order by p.ynum rows between current row and z.num-1 following) as sumploverx


-- sum() as an analytic function is doing all the hard work
--   partition by p.xnum,z.num -> we're generating the 
select p.xnum, p.ynum, p.pl, z.num znum
   , sum(p.pl) over (partition by p.xnum,z.num order by p.ynum rows between current row and z.num-1 following) as sumploverx
 from powerlevel p, rowgen z
